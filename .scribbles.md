ᕦ(ツ)ᕤ
# scribbles
*stupid ideas / thoughts*

Ideas for today's session. 
Really into the idea of making a "queryable spec"

--------------------------------------------------

there's definitely a tension between "object-definition" and "here's a collection of objects".

platform => is a type of a thing.
but also, platform$/...

--------------------------------------------------

miso is about *getting things done*.
it's not about *writing code* or *making actions* or *writing specs*.
it's about "I want to do this now"
and we do it, and we fight through it, but then the *next time we do it*, it's easier, because we can look back on the original chat and learn from it.
and we can only do that if the chat is *task-focused*.

so there has to be this idea of "create a new task"
we spin up a new agent with a subtask and a spec.

---------------------------------------------------

Thoughts about how things evolve towards automation.

1- "spec" is shorthand for a feature-tree.
2- the spec can be made into a super simple micro-agent: you ask it questions, it responds with an answer (together with the features that support it).
3- you then put the spec "agent" into a chatroom with engineers and agents.
4- the topic of the chatroom is "the task to be performed" eg. "build hello"

This is the idea that unifies "claude" vs "claude code".
one of the agents has the baton, and it gets to do stuff.

Has to be multi-agent.
Has to have local agents.

That I think is the right answer for agent collaboration.

When you initiate an action, we spin up another task-room.
What's also super nice is that you can pass in a PLAN.
A plan is just an Action. => Yeah baby.

OK so a TASK:

is 
- an action specification ("what we need to do to whom")
- a context you can as questions of ("context" agent)
- one or more agents
- one or more humans
- the agents / humans talk together, make changes to the system, run things
- if they need to know something, they ask the context agent
- if it doesn't know, they ask the user if available
- if the user's not available, we either flag to disturb them / wait for them, or make some reasonable assumption based on their preferences.

oh, haha, a user's preferences can also be a queryable context.
=> that's interesting and super cool.
=> so you just need to ask-preferences.

haha, so plan, task, user, guidelines can all be agents in a chat? 
if they're all local and deterministic, that's easy to do.

So I like this concept of "micro-agents". Deterministic agents. They're in between tools and agents- they always work locally, so there's no callout to an API. THAT is the difference. So you can totally have a local fixed "home" LLM that is super reliable at certain tasks.

Anyhoo: 
so:
each time you work on a task, you can look back at the chat and figure out what to do better next time, etcetc. In other words, the experience leads to new features in the system.

So they're a learnable resource.
As you discover combinations of "micro-agents" (need a name) that are reliable for certain tasks, then those actions get compiled into a new micro-agent.

miso: => start a new task/chat with that task in it.
OK so this is totally a fucking THING.

If we were doing this using markdown, it would be the exact same structure:

conversations/
    xcodebuild/         => sub-conversations / tasks
    xcodebuild.md       => the whole conversation

These are the same, they just don't have the length restrictions!
This is the "learning" that we undergo, and we have to keep it. We can't keep throwing it away.

But the idea of a "queryable context" is a KILLER idea.
And can be built next.


--------------------------

added '~' idea to disable features: perfect.
so you can sketch features! 
see ~collaboration
also need to add 'soft link' idea, because it's good.

--------------------------

right way forward:
edit the tree off-air; 
try to build stuff on-air.

first goal is just the human spec editor.
make it super nice for humans and for agents.

aha that's it! it's the lens through which we interact with the tree.
the editor, written in itself.
that's beautiful.
just make it so damn cool that nobody can resist it.

aim at users, not devs... reject dev conventions, think how the user does.

*but* key insight: make a proper role of "engineer".

--------------------------------------

decisions on this one:

- A/B/C.md 
- A/B/C~ for meta stuff

nice because
- everything's visible
- you can totally copy trees around
- we can put feature-dependent code snippets there

using the term *storage* for file organisation;
using the term *howtos* for actions.

hm should I go singular... then it becomes an object!!

making an attempt to truly address the user.
-> trouble is you don't know who the user is.
=> if I make it for myself, it's going to be more complex
=> so I should always make it FOR MYSELF. rather than some imaginary other person.






------------------------------------

OK, random afternoon* background-level thoughts and feelings.
1- putting the experiments out on youtube is good.
2- we actually got somewhere with the previous experiments
3- we need tighter control over the low-level.

So what things do we know?

- it's possible to author apps across platforms
- need platform experts
- for sure, we need multiple communicating micro-agents

so here the ideas of *actions*, *tools* and *tasks* need to be clarified.

So I think rather than reifying the term "feature-modular", let's just call them snippets, and we're done.

We DO need to sort out the annoying list/ thing. I think the way we do it is:

    miso/tools.md                       # tools overview
    miso/tools/determinism.md           # sub-detail about tools
    misol/tools/all/hello.md            # hello world tool

action= "do a thing". these are natural-language-specified howtos.
tool= "bit of code". deterministic code, repeatable.
task= "a specific goal to be achieved."
plan= steps we're going to undertake

can tools call external APIs?
I think there should be a category difference. So I'd say, "no".

tools
actions

----------------------------------

definitely needs to be some work on "visibility"
-> seeing what the browser is doing
-> seeing console
-> seeing what a server is doing
-> etc.

-----------------------------------

first experiment failed: because "build" isn't a tool.
It SHOULD have made it call out to some agent stuff.
But it didn't. So we have to try again.

I wonder if we can self-critique... but can't be arsed.
Let's try again tomorrow.

-----------------------------------

"actions" - how to do things, step by step.
also a tree.

I guess we could also make "plans" for doing stuff.

They're all tree-docs.

-------------------------------------

ChatGPT much more verbose and "clever" than Claude, I don't understand it half the time.

Needs to be a firm boundary between "what the user wrote" and "what the agent wrote".

Maybe even something like "all agent-written files should be named starting with `~`"





